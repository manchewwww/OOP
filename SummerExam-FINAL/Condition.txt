Разглеждаме абстрактен базов клас Множество, което е съставено от елементи от произволен тип, но всички елементи в него са от един и същ тип. Едно множество задължително трябва да има оператор за индексиране, който връща булев резултат - дали подадения като аргумент елемент принадлежи на множеството.
Наследници на това множество са следните конкретни класове:

●     Крайно множество, чиито елементи се подават като масив в конструктора. Да се гарантира, че сред тях няма повторения!

●     Множество-интервал – в конструктора се подават два елемента – граници на интервала. Всички елементи на множеството трябва са по-големи или равни на по-малкия от подадените елементи и по-малки или равни на по-големия от подадените в конструктора елементи.

●     Множество по критерий – в конструктора се подава предикат (булева функция), който определя дали даден елемент принадлежи на множеството или не.

●     Сечение на множества – в конструктора се подават едно или повече множества. Създаденият обект (сечение) съдържа даден елемент, когато този елемент се съдържа във всяко от посочените множества. Елементите на всички множества от сечението са от един и същ тип.

●      Обединение на множества - в конструктора се подават едно или повече множества. Създаденият обект (обединение) съдържа даден елемент, когато този елемент се съдържа в поне едно от посочените множества. Елементите на всички множества от обединението са от един и същ тип.

Реализирайте класовете според добрите ООП практики и презумпцията за гъвкавото им използване.


Реализирайте програма, която прочита от текстов файл множество от символни низове – имена на файлове. Всяко име е разположено на отделен ред и може да съдържа произволни символи, валидни за име на файл в съответната файлова система. Всеки от тези файлове е двоичен и съдържа две цели, 16 битови числа N и Т, следвани от N символни низа, всеки записан като 16 битово число L – броя символи в низа, следван от L символа – самият низ. Те не включват терминираща нула.

Стойността на T разглеждаме като поредица от битове, която определя какъв тип множество ще определят тези низове и как ще се добави то към резултата. Най-младшите два бита определят начина на добавяне, а останалите 14 - типа на множеството.

За начин на добавяне разглеждаме три стойности:
0 – съответното множество замества резултата, без значение на предишни прочетени множества
1 – съответното множество се добавя като обединение към получения до момента резултат
2 – съответното множество се добавя като сечение към получения до момента резултат

За тип на множествата разглеждаме следните стойности:
0 – Файлът описва крайно множество. Елементите са N-те низа.
1 – Файлът описва множество - интервал. В този случай N задължително трябва да е 2. Двата последващи низа определят интервала.
2 – Файлът описва множество по критерий. Негови елементи са низовете, които съдържат някой от подадените N низа в себе си.
3 – Файлът описва множество по критерий. Негови елементи са низовете, които са конкатенация на някои два от подадените низове.
4 – Файлът описва сечение на множество интервали. N задължително трябва да е четно число. Всеки два последователни низа във файла описват един интервал и резултатното множество е сечението им.
5 – Файлът описва обединение на множество интервали. N задължително трябва да е четно число. Всеки два последователни низа във файла описват един интервал и резултатното множество е обединението им.

От данните във всеки файл създайте съответното множество. Това множество добавете към резултатно множество, съгласно описаното във файла – замяна, обединение и съответно сечение с него. Операцията от първия файл се игнорира и винаги започвате с полученото от него множество. Започвате да прилагате операциите от втория файл към първия, след това от третия към резултата и така нататък.

Накрая въведете от клавиатурата текст до край на файл. За всеки от редовете му проверете дали се съдържа в резултатното множество и изведете броя на тези редове.

Подсигурете коректността на данните. Подсигурете коректна работа с всички ресурси.

Позволено е използването на стандартните библиотеки за работа с потоци и файлове, както и на класовете std::string и std::vector. Също библиотеките за работа със стандартни изключения в C++, както и стандартната библиотека на езика C за работа със символни низове.